---
title: 'Assignment 1'
author: 'Eng Jing Min Belinda, Lee Pei Yi, Ong Mei Zhen, Tham Hoi Yew Leon'
date: '20 January 2019'
output: html_document
---

```{r setup, include=FALSE}
options(warn=-1)
library(microbenchmark)
library(ggplot2)
#install.packages('formattable')
library('formattable')
```

#Q1

Calculate the annual incomes of the employees and store them in currency format into a vector named annual.income. You must name the vector with the employee names according.

```{r}
# Input given vectors: salary & score
salary <- c(James="$3,837.45", Jack="$6,353.36", Jones="$12,989.45", Tom="$3,772")
score <- c(James = 1.3, Jack = 1.5, Jones = 3.2, Tom = 5.4)
```

The 'salary' vector is in characters format. Hence, it is necessary to convert it from strings to currency format.

```{r}
# To convert vector from character format to currency
salary <- currency(salary, symbol = "$")

annualscore <- score + 12

Annual.income <- annualscore * salary

Annual.income
```

# Q2

# Question 2
Please try to generate a vector of numbers with following pattern: 1,4,7,10,â€¦,100. Try as many ways as possible.

## Method 1 - Using `seq` and `c`
```{r q2a, fig.width=10}
m1.1 <- seq(1,100,3)
cat('Method 1.1:', m1.1)
m1.2 <- seq(1,100,length.out=34)
cat('Method 1.2:', m1.2)
m1.3 <- seq.int(1,100,3)
cat('Method 1.4:', m1.3)
m1.4 <- seq.int(1,100,length.out=34)
cat('Method 1.4:', m1.4)
m1.5 <- 3*c(0:33) + 1
cat('Method 1.5:', m1.5)

m1 <- microbenchmark('m1.1' = {seq(1,100,3)},
                     'm1.2' = {seq(1,100,length.out=34)},
                     'm1.3' = {seq.int(1,100,3)},
                     'm1.4' = {seq.int(1,100,length.out=34)},
                     'm1.5' = {3*c(0:33) + 1}
                     )

boxplot(m1, unit='ns',log=F,horizontal=T,col=topo.colors(5))
legend('topright',
       title='Methods',
       c('seq(by)','seq(length.out)','seq.int(by)','seq.int(length.out)','c()'), 
       fill=topo.colors(5)
       )
```
It is clear that `seq.int` is much faster than the vanilla `seq`. Using `c()` followed by some arithmetric operations is fast but still slightly slower. Also, using the argument `length.out` is slightly quicker than the argument `by`.

## Method 2 - Vector filtering
```{r q2b, fig.width=10}
m2_vector <- c(1:100)

m2.1 <- m2_vector[m2_vector%%3 == 1]
cat('Method 2.1:', m2.1)

m2.2 <- m2_vector[c(T,F,F)]
cat('Method 2.2:', m2.2)

m2.3 <- subset(m2_vector,m2_vector%%3==1)
cat('Method 2.3:', m2.3)

m2.4 <- subset(m2_vector,c(T,F,F))
cat('Method 2.4:', m2.4)

m2 <- microbenchmark('m2.1' = {m2_vector[m2_vector%%3 == 1]},
                     'm2.2' = {m2_vector[c(T,F,F)]},
                     'm2.3' = {subset(m2_vector,m2_vector%%3==1)},
                     'm2.4' = {subset(m2_vector,c(T,F,F))}
                     )

boxplot(m2, unit='ns',log=F,horizontal=T,col=topo.colors(4))
legend('topright',
       title='Methods',
       c('[%%]','[c()]','subset(%%)','subset(c)'), 
       fill=topo.colors(4)
       )
```
Filtering via square brackets notation is quicker than using the function call `subset`. Also filtering under the condition of a vector `c(T,F,F)` is quicker than doing an a modulo `%%` calculation.

## Method 3 - Matrix filtering
```{r q2c, fig.width=10}
m3.1 <- matrix(c(1:100),3,34)[1,]
cat('Method 3.1:', m3.1)

m3.2 <- matrix(c(1:100),34,3,byrow=T)[,1]
cat('Method 3.2:', m3.2)

m3 <- microbenchmark('m3.1' = {matrix(c(1:100),3,34)[1,]},
                     'm3.2' = {matrix(c(1:100),34,3,byrow=T)[,1]}
                     )

boxplot(m3, unit='ns',log=F,horizontal=T,col=topo.colors(2))
legend('topright',
       title='Methods',
       c('bycol','byrow'), 
       fill=topo.colors(2)
       )
```
Both methods seems to be equally quick.

## Method 4 - Loops
```{r loops, fig.width=10}
m4.1 <- c()
for (i in 0:33)
  m4.1[i+1] <- 1 + (3*i)
cat('Method 4.1:', m4.1)

m4.2 <- c()
a <- 1
while(a <= 100){
  m4.2 <- c(m4.2,a)
  a = a + 3
}
cat('Method 4.2:', m4.2)

m4 <- microbenchmark('m4.1' = {m4.1 <- c()
                               for (i in 0:33)
                                 m4.1[i+1] <- 1 + (3*i)
                               },
                     'm4.2' = {m4.2 <- c()
                               a <- 1
                               while(a <= 100){
                                 m4.2 <- c(m4.2,a)
                                 a = a + 3
                               }}
                     )

boxplot(m4, unit='ns',log=F,horizontal=T,col=topo.colors(2))
legend('topright',
       title='Methods',
       c('for loop','while loop'), 
       fill=topo.colors(2)
       )
```
The for loop seems slightly slower than the while loop.

## Speed comparison
Comparing the timings of the fastest of each method group.
```{r overall, fig.width=10}
ov <- microbenchmark('m1.4' = {seq.int(1,100,length.out=34)},
                     'm2.2' = {m2_vector[c(T,F,F)]}#,
                     #'m3.2' = {matrix(c(1:100),3,34)[1,]},
                     #'m4.2' = {m4.2 <- c()
                     #         a <- 1
                     #         while(a <= 100){
                     #          m4.2 <- c(m4.2,a)
                     #          a = a + 3
                     #        }}
                     )

boxplot(ov, unit='ns',log=F,horizontal=T,col=topo.colors(4))
legend('topright',
       title='Methods',
       c('m1.4','m2.2'), 
       fill=topo.colors(4)
       )
```
In general methods 1 is the fastest, followed by methods 2 then method 3 and lastly methods 4. (Methods 3 and 4 is not included as it is way slower. Uncomment the codes to see the difference.) 


# Question 3

Try to generate the following vector: "a1","b1","c1","a2","b2","c2",.,"a10", "b10", "c10".

```{r}
paste(rep(letters[1:3], 10), rep(1:10, each = 3), sep = "") 
```

```{r}
# Or a faster way without specifying the sep argument:
paste0(rep(letters[1:3], 10), rep(1:10, each = 3))
```

# Question 4
Create a 5x5 symmetric matrix so that its diagonal is (5,5,5,5,5) and all the rest of elements are 1.
Now suppose I want to generalise (1) to an nxn matrix for any number n. How to do that?

```{r q4}
make_symmetric_matrix <- function(n,diagonal,others=1,by=1){
  # INPUTS
  # n        : height/width of matrix
  # diagonal : value to set as diagonal(s)
  # others   : value to set elsewhere
  # by       : 1=top left to bottom right, 2=bottom left to top right 3=both diagonals
  m <- matrix(rep(others,n**2),nrow=n,ncol=n)
  diag(m) <- diagonal
  if (by==1)
    return (m)
  else if (by==2)
    return (apply(m,2,rev))
  else{
    m <- apply(m,2,rev)
    diag(m) <- diagonal
    return (m)
  }
}

make_symmetric_matrix(5,5,1,1)
make_symmetric_matrix(5,5,1,2)
make_symmetric_matrix(5,5,1,3)
```
